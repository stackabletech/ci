---
{% for testsuite in testsuites %}
- job:
    name: {{ testsuite.id }}-it-custom
    project-type: freestyle
    defaults: global
    description: ''
    disabled: false
    display-name: '{{ testsuite.display_name }} custom test'
    concurrent: true
    quiet-period: 5
    logrotate:
      daysToKeep: -1
      numToKeep: 20
      artifactDaysToKeep: -1
      artifactNumToKeep: -1
    scm:
      - git:
          url: https://github.com/stackabletech/{{ testsuite.git_repo }}.git
          branches:
            - $GIT_BRANCH_OR_TAG
          browser: githubweb
          browser-url: https://github.com/stackabletech/{{ testsuite.git_repo }}.git
          timeout: 20
    parameters:
      - choice:
          name: TEST_PLATFORM
          choices:{% for platform in testsuite.platforms %}{% for version in platforms[platform.id].versions %}
            - {{ platforms[platform.id].name }} ({{ version }}){% endfor %}{% endfor %}
          description: On which platform should the test run?
      - git-parameter:
          name: GIT_BRANCH_OR_TAG
          description: The Git branch or tag where your Operator integration tests are, defaults to 'main'.
          type: PT_BRANCH_TAG
          selectedValue: NONE
          sortMode: ASCENDING_SMART
          defaultValue: origin/main
      - choice:
          name: OPERATOR_VERSION
          description: Version of the operator (binary) this test should use
          choices:{% for version in operator_versions[testsuite.id] %}
            - {{ version }}{% endfor %}
      - string:
          name: TEST_SCRIPT_PARAMS
          description: Use this string to specify a list of params/options for the test script.
          trim: true
      - choice:
          name: TEST_SCRIPT
          choices:
            - Default (from catalog)
            - Auto-retry
            - run-tests
          description: "Test execution mode: Default uses catalog configuration, Auto-retry uses a script to automatically retry failing tests, run-tests just runs the tests once"
    wrappers:
      - credentials-binding:
        - text:
            credential-id: REPLICATED_API_TOKEN
            variable: REPLICATED_API_TOKEN
        - username-password-separated:
            credential-id: IONOS_API
            username: IONOS_USERNAME
            password: IONOS_PASSWORD
        - username-password-separated:
            credential-id: CLUSTER_LOGGING
            username: CLUSTER_LOGGING_USERNAME
            password: CLUSTER_LOGGING_PASSWORD
      - build-user-vars
    builders:
      - shell:
          unstable-return: 255
          command: |
            # ---------------------------------------------------------------------------------------------
            # This Jenkins job has been generated by the Stackable Jenkins JobBuilder
            # ---------------------------------------------------------------------------------------------

            # We're using Docker from within a Docker container, so we have to make sure to provide
            # the Docker daemon with the proper absolute path for volume mounts.
            # HOST_WORKSPACE is the absolute path of this job's workspace folder as used on the actual Docker host.
            export HOST_WORKSPACE=`echo $WORKSPACE | sed 's~jenkins_home~jenkins/data~'`

            # The Docker image we're using is running under root (and must do so), so
            # we're providing it with a User/Group ID so that it can write the output files using this User/Group.
            # Otherwise we might end up with root-owned files which cannot be cleaned up by Jenkins
            export OUTPUT_FILE_USER="$(id -u):$(id -g)"

            # Read the keys of the selection parameters
            export PLATFORM=`echo $TEST_PLATFORM | cut -d '(' -f 1`
            export PLATFORM_VERSION=`echo $TEST_PLATFORM | cut -d '(' -f 2 | cut -d ')' -f 1`
            export GIT_BRANCH=`echo $GIT_BRANCH_OR_TAG | sed s#origin/##g`

            echo "build_description::#$TEST_PLATFORM#"

            # Run test
            mkdir -p target/
            docker run --rm \
              --volume "$HOST_WORKSPACE/target/:/target/" \
              --env OUTPUT_FILE_USER=$OUTPUT_FILE_USER \
              --env REPLICATED_API_TOKEN=$REPLICATED_API_TOKEN \
              --env IONOS_USERNAME=$IONOS_USERNAME \
              --env IONOS_PASSWORD=$IONOS_PASSWORD \
              --env PLATFORM="$PLATFORM" \
              --env PLATFORM_VERSION="$PLATFORM_VERSION" \
              --env OPERATOR={{ testsuite.id }} \
              --env OPERATOR_VERSION="$OPERATOR_VERSION" \
              --env CLUSTER_LOGGING_ENDPOINT='{{ cluster_logging_endpoint }}' \
              --env CLUSTER_LOGGING_USERNAME="$CLUSTER_LOGGING_USERNAME" \
              --env CLUSTER_LOGGING_PASSWORD="$CLUSTER_LOGGING_PASSWORD" \
              --env OPENSEARCH_DASHBOARDS_URL='{{ opensearch_dashboards_url }}' \
              --env GIT_BRANCH=$GIT_BRANCH \
              --env TEST_SCRIPT_PARAMS="$TEST_SCRIPT_PARAMS" \
              --env TEST_SCRIPT="$TEST_SCRIPT" \
              --env VECTOR_AGGREGATOR='vector-aggregator.default.svc.cluster.local:6000' \
              oci.stackable.tech/operator-test-runner:latest
    publishers:
      - archive:
          artifacts: 'target/**'
          allow-empty: true
      - slack:
          room: '{{ slack_channel }}'
          notify-success: True
          notify-unstable: True
          notify-every-failure: True
          notify-back-to-normal: True
          include-custom-message: True
          custom-message: |
            *$TEST_PLATFORM*
            (started by $BUILD_USER)
            *Git branch* `$GIT_BRANCH`
            *{{ testsuite.display_name }} version* `$OPERATOR_VERSION`
            *Test script params* `$TEST_SCRIPT_PARAMS`
            *Test script* `$TEST_SCRIPT`
      - description-setter:
          regexp: ".*build_description::#(.*)#.*"
          regexp-for-failed: ".*build_description::#(.*)#.*"
          set-for-matrix: false
{% endfor %}
