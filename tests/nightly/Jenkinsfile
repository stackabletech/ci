pipeline {
    agent any
    options {
        ansiColor('xterm')
        buildDiscarder(logRotator(numToKeepStr: '5', artifactNumToKeepStr: '5'))
    }

    stages {

        stage('assert parameters') {
            when {
                anyOf {
                    expression { env.TEST_NAME == null }
                }
            }
            steps {
                error('Please select an operator using the environment variable TEST_NAME')
            }
        }

        stage('prepare environment on Jenkins worker') {
            steps {
                script {
                    env.HOST_WORKSPACE = sh(script: 'echo ${WORKSPACE} | sed \'s~jenkins_home~jenkins/data~\'', returnStdout: true).trim()
                    env.JENKINS_USER_GROUP = sh(script: 'echo "$(id -u):$(id -g)"', returnStdout: true).trim()
                }
                script {
                    sh """
                        echo \"The Jenkins workspace folder as seen from the Docker daemon: '${env.HOST_WORKSPACE}'\"
                        echo \"The Docker user parameter value for T2 testdriver: '${env.JENKINS_USER_GROUP}'\"
                        docker pull docker.stackable.tech/ci-preprocessor:latest
                        docker pull docker.stackable.tech/t2-testdriver:latest
                        mkdir -p target/
                    """
                }
            }
        }

        stage('generate test files') {
            steps {
                sh """
                    docker run \
                        --volume "${env.HOST_WORKSPACE}"/target/:/target/ \
                        --volume "${env.HOST_WORKSPACE}"/tests/nightly/tests.yaml:/tests.yaml \
                        --volume "${env.HOST_WORKSPACE}"/tests/platforms.yaml:/platforms.yaml \
                        --user ${env.JENKINS_USER_GROUP} \
                        --env TEST_NAME=${env.TEST_NAME} \
                        docker.stackable.tech/ci-preprocessor:latest
                    mkdir -p target/${env.TEST_NAME}/target/
                """
            }
        }

        stage('run test') {
            steps {
                withCredentials([string(credentialsId: 'T2_TOKEN', variable: 'T2_TOKEN')]) {
                    script {
                        // run the test in the T2 testdriver container
                        testdriverExitCode = sh (script: """
                            touch target/${env.TEST_NAME}/target/test.log
                            exit 254
                        """, returnStatus: true)

// TODO this is "the real thing" and has to be activated
//                            docker run \
//                                --volume "${env.HOST_WORKSPACE}"/target/${env.TEST_NAME}/target/:/target/ \
//                                --volume "${env.HOST_WORKSPACE}"/target/${env.TEST_NAME}/cluster.yaml:/cluster.yaml \
//                                --volume "${env.HOST_WORKSPACE}"/target/${env.TEST_NAME}/test.sh:/test.sh \
//                                --env T2_TOKEN=$T2_TOKEN \
//                                --env T2_URL=https://t2.stackable.tech \
//                                --env UID_GID=${env.JENKINS_USER_GROUP} \
//                                docker.stackable.tech/t2-testdriver    


                        // This error handling section looks weird...
                        // Depending on the outcome of the T2 testdriver run,
                        // we set the result to UNSTABLE, raise an ERROR or do nothing.
                        // The surrounding catchError() makes sure that following steps
                        // are executed regardless of the outcome of this stage
                        catchError(message: 'test failed', stageResult: 'FAILURE') {
                            if(testdriverExitCode != 0) {
                                if (testdriverExitCode == 255) {
                                    unstable(message: "cluster launch failed")
                                } else if (testdriverExitCode == 254) {
                                    unstable(message: "cluster termination failed")
                                } else  {
                                    error(message: "test failed")
                                }
                            }
                        }
                    }
                }
            }
        }

        stage('archive artifacts') {
            steps {
                archiveArtifacts allowEmptyArchive: true, artifacts: "target/${env.TEST_NAME}/target/**", defaultExcludes: false, followSymlinks: false
            }
        }

        stage('cleanup') {
            steps {
                cleanWs()
            }
        }
    }

    post {
        unstable {
            slackSend channel: 'U02G2BBMZHR', message: "*${env.JOB_NAME}* - ${env.BUILD_DISPLAY_NAME} is *unstable* (<${env.BUILD_URL}|Open in Jenkins>)", color: 'warning'
        }
        failure {
            slackSend channel: 'U02G2BBMZHR', message: "*${env.JOB_NAME}* - ${env.BUILD_DISPLAY_NAME} *failed* (<${env.BUILD_URL}|Open in Jenkins>)", color: 'danger'
        }
        fixed {
            slackSend channel: 'U02G2BBMZHR', message: "*${env.JOB_NAME}* - ${env.BUILD_DISPLAY_NAME} *back to normal* :smiley: (<${env.BUILD_URL}|Open in Jenkins>)", color: 'good'
        }
    }

}


