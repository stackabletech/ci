---
{% for testsuite in testsuites %}
- job:
    name: {{ testsuite.name }}-documentation-test
    project-type: freestyle
    defaults: global
    description: ''
    disabled: false
    display-name: '{{ testsuite.display_name }} documentation test'
    concurrent: true
    quiet-period: 5
    logrotate:
      daysToKeep: -1
      numToKeep: 20
      artifactDaysToKeep: -1
      artifactNumToKeep: -1
    scm:
      - git:
          url: https://github.com/stackabletech/{{ testsuite.git_repo }}.git
          branches:
            - ${GIT_BRANCH_OR_TAG}
          browser: githubweb
          browser-url: https://github.com/stackabletech/{{ testsuite.git_repo }}.git
          timeout: 20
    parameters:
      - git-parameter:
          name: GIT_BRANCH_OR_TAG
          description: The Git branch or tag where your Operator documentation tests are, defaults to 'main'.
          type: PT_BRANCH_TAG
          selectedValue: NONE
          sortMode: ASCENDING_SMART
          defaultValue: origin/main
      - choice:
          name: TEST_PLATFORM
          choices:{% for platform in platforms[testsuite.name] %}
            - {{ platform.display_name }}, {{ platform.version }} <{{ platform.id }}|{{ platform.version }}>{% endfor %}
          description: On which platform should the test run?
    wrappers:
      - credentials-binding:
          - text:
              credential-id: T2_TOKEN
              variable: T2_TOKEN
      - build-user-vars
      - workspace-cleanup
    builders:
      - shell: 
          unstable-return: 255
          command: |
            # ---------------------------------------------------------------------------------------------
            # This Jenkins job has been generated by the Stackable CI Testing Toolbox
            # ---------------------------------------------------------------------------------------------

            # Read the keys of the selection parameters
            export PLATFORM_ID=`echo $TEST_PLATFORM | cut -d '<' -f 2 | cut -d '|' -f 1`
            export K8S_VERSION=`echo $TEST_PLATFORM | cut -d '<' -f 2 | cut -d '|' -f 2 | cut -d '>' -f 1`
            export GIT_BRANCH=`echo $GIT_BRANCH_OR_TAG | sed s#origin/##g`

            # We're using Docker from within a Docker container, so we have to make sure to provide
            # the Docker daemon with the proper absolute path for volume mounts.
            # HOST_WORKSPACE is the absolute path of this job's workspace folder as used on the actual Docker host.
            export HOST_WORKSPACE=`echo $WORKSPACE | sed 's~jenkins_home~jenkins/data~'`

            # The T2 testdriver Docker image we're using is running under root (and must do so), so
            # we're providing it with a User/Group ID so that it can write the output files using this User/Group.
            # Otherwise we might end up with root-owned files which cannot be cleaned up by Jenkins
            export DOCKER_UID_GID="$(id -u):$(id -g)"

            # Pull the testdriver Docker image
            docker pull docker.stackable.tech/t2-testdriver:latest
            
            # Make sure the target directory exists
            mkdir -p target/

            # Create a testsuite
            create_testsuite () {
                TESTSUITE_DIR=$(echo $1 | sed -e 's|.sh|/|')
                echo "" >> target/_summary.txt
                echo "Creating testsuite for '$1' in folder testsuites/${TESTSUITE_DIR}..." >> target/_summary.txt

                mkdir -p testsuites/${TESTSUITE_DIR}target/
                mkdir -p testsuites/${TESTSUITE_DIR}testsuite/

                # create testsuite
                docker run --rm \
                    --volume "$HOST_WORKSPACE/testsuites/${TESTSUITE_DIR}testsuite/:/target/" \
                    --env TESTSUITE={{ testsuite.name }} \
                    --env PLATFORM=$PLATFORM_ID \
                    --env K8S_VERSION=$K8S_VERSION \
                    --env GIT_BRANCH=$GIT_BRANCH \
                    --env TEST_SCRIPT="docs/$1" \
                    --env METADATA_ANNOTATION_t2.stackable.tech/jenkins-user="${BUILD_USER}" \
                    --env METADATA_ANNOTATION_t2.stackable.tech/jenkins-user-id=${BUILD_USER_ID} \
                    --env METADATA_ANNOTATION_t2.stackable.tech/jenkins-user-email=${BUILD_USER_EMAIL} \
                    docker.stackable.tech/testing-toolbox:latest create-docs-testsuite

                echo "Created testsuite for '$1' in folder testsuites/${TESTSUITE_DIR}." >> target/_summary.txt
            }

            # Run a testsuite
            run_testsuite () {
                TESTSUITE_DIR=$(echo $1 | sed -e 's|.sh|/|')
                echo "" >> target/_summary.txt
                echo "Running testsuite for '$1' ..." >> target/_summary.txt

                # A failing test should not terminate the whole job
                set +e

                # Run testdriver
                docker run --rm \
                    --volume "$HOST_WORKSPACE/testsuites/${TESTSUITE_DIR}target/:/target/" \
                    --volume "$HOST_WORKSPACE/testsuites/${TESTSUITE_DIR}testsuite/cluster.yaml:/cluster.yaml" \
                    --volume "$HOST_WORKSPACE/testsuites/${TESTSUITE_DIR}testsuite/test.sh:/test.sh" \
                    --env CLUSTER=MANAGED \
                    --env T2_TOKEN=$T2_TOKEN \
                    --env T2_URL=https://api.t2.stackable.tech \
                    --env OPENSEARCH_DASHBOARDS_URL=https://logs.t2.stackable.tech \
                    --env UID_GID=$DOCKER_UID_GID \
                    docker.stackable.tech/t2-testdriver    

                # catch result of test run
                test_result=$?
                set -e
                
                # Archive the artifacts of this testsuite
                mkdir -p "target/${TESTSUITE_DIR}"
                cp -r "testsuites/${TESTSUITE_DIR}target/"* "target/${TESTSUITE_DIR}"

                # If test cluster could not be created => unstable
                if [ $test_result -eq 255 ]; then
                    echo "Testsuite '$1': UNSTABLE cluster" >> target/_summary.txt
                    echo "" >> target/_summary.txt
                    echo "Due to the unstable cluster in testsuite '$1', the job will be aborted." >> target/_summary.txt
                    exit 255
                fi

                if [ $test_result -eq 0 ]; then
                    echo "Testsuite '$1': PASSED" >> target/_summary.txt
                else
                    echo "Testsuite '$1': FAILED" >> target/_summary.txt
                    result=1
                fi
            }

            result=0

            # Discover all the testsuites in this repository
            testscripts=$(find docs/ -name 'test_*.sh' | sed -e 's|^docs/||')
            echo "Running the following testscripts:" > target/_summary.txt
            for testscript in $testscripts; do
                echo "- $testscript" >> target/_summary.txt
            done

            # Generate the testsuites
            for testscript in $testscripts; do
                create_testsuite $testscript
            done

            # Run the testsuites
            for testscript in $testscripts; do
                run_testsuite $testscript
            done

            exit $result
    publishers:
      - archive:
          artifacts: 'target/*'
          allow-empty: true
      - slack:
          room: '{{ testsuite.nightly_test.slack_channels }}'
          notify-unstable: True
          notify-every-failure: True
          notify-back-to-normal: True
          include-custom-message: True
          custom-message: |
            (<$BUILD_URL|Open in classic Jenkins UI>)
{% endfor %}

