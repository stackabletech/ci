---
{% for testsuite in testsuites %}
- job:
    name: {{ testsuite.name }}-it-self-service
    project-type: freestyle
    defaults: global
    description: ''
    disabled: false
    display-name: '{{ testsuite.display_name }} test self service cluster'
    concurrent: true
    quiet-period: 5
    logrotate:
      daysToKeep: -1
      numToKeep: 20
      artifactDaysToKeep: -1
      artifactNumToKeep: -1
    parameters:
      - choice:
          name: TEST_PLATFORM
          choices:{% for platform in platforms[testsuite.name] %}
            - {{ platform.display_name }}, {{ platform.version }} <{{ platform.id }}|{{ platform.version }}>{% endfor %}
          description: On which platform should the test run?
      - extended-choice:
          name: OPERATOR_VERSION
          description: Version of the operator (binary) this test should use
          property-file: /var/jenkins_home/workspace/Available Versions/versions.properties
          property-key: {{ testsuite.name }}
          quote-value: false
          visible-items: 10
      - string:
          name: CLUSTER_NICKNAME
          description: Nickname of the cluster to be created (mandatory)
          trim: true
    wrappers:
      - credentials-binding:
          - text:
              credential-id: T2_TOKEN
              variable: T2_TOKEN
      - build-user-vars
    builders:
      - shell: 
          unstable-return: 255
          command: |
            # ---------------------------------------------------------------------------------------------
            # This Jenkins job has been generated by the Stackable CI Testing Toolbox
            # ---------------------------------------------------------------------------------------------

            if [ -z "$CLUSTER_NICKNAME" ]; then
              echo "The cluster nickname must not be empty!"
              exit 1
            fi

            # Read the keys of the selection parameters
            export PLATFORM_ID=`echo $TEST_PLATFORM | cut -d '<' -f 2 | cut -d '|' -f 1`
            export K8S_VERSION=`echo $TEST_PLATFORM | cut -d '<' -f 2 | cut -d '|' -f 2 | cut -d '>' -f 1`

            # We're using Docker from within a Docker container, so we have to make sure to provide
            # the Docker daemon with the proper absolute path for volume mounts.
            # HOST_WORKSPACE is the absolute path of this job's workspace folder as used on the actual Docker host.
            export HOST_WORKSPACE=`echo $WORKSPACE | sed 's~jenkins_home~jenkins/data~'`

            # The T2 testdriver Docker image we're using is running under root (and must do so), so
            # we're providing it with a User/Group ID so that it can write the output files using this User/Group.
            # Otherwise we might end up with root-owned files which cannot be cleaned up by Jenkins
            export DOCKER_UID_GID="$(id -u):$(id -g)"

            # Pull the testdriver Docker image
            docker pull docker.stackable.tech/t2-testdriver:latest
            
            # Create testsuite files
            mkdir -p testsuite/
            docker run --rm \
              --volume "$HOST_WORKSPACE/testsuite/:/target/" \
              --env TESTSUITE={{ testsuite.name }} \
              --env PLATFORM=$PLATFORM_ID \
              --env K8S_VERSION=$K8S_VERSION \
              --env OPERATOR_VERSION=$OPERATOR_VERSION \
              --env METADATA_ANNOTATION_t2.stackable.tech/jenkins-user=${BUILD_USER} \
              --env METADATA_ANNOTATION_t2.stackable.tech/jenkins-user-id=${BUILD_USER_ID} \
              --env METADATA_ANNOTATION_t2.stackable.tech/jenkins-user-email=${BUILD_USER_EMAIL} \
              docker.stackable.tech/testing-toolbox:latest create-testsuite

            # Collect information to print out after the test job
            export BUILD_RUN_PLATFORM=`cat testsuite/cluster.yaml | yq -e '.metadata.description'`
            export BUILD_RUN_K8S_VERSION=`cat testsuite/cluster.yaml | yq -e '.spec.k8sVersion'`

            # This string can be parsed by the description-setter publisher
            echo "build_run_label::#${BUILD_RUN_PLATFORM} | ${BUILD_RUN_K8S_VERSION} | ${CLUSTER_NICKNAME} | ${BUILD_USER}#"

            # Run testdriver
            mkdir -p testsuite/target/
            docker run --rm \
              --volume "$HOST_WORKSPACE/testsuite/target/:/target/" \
              --volume "$HOST_WORKSPACE/testsuite/cluster.yaml:/cluster.yaml" \
              --env CLUSTER=CREATE \
              --env T2_TOKEN=$T2_TOKEN \
              --env T2_URL=https://api.t2.stackable.tech \
              --env UID_GID=$DOCKER_UID_GID \
              docker.stackable.tech/t2-testdriver:latest

            # Extract cluster ID from log
            export CLUSTER_ID=`cat testsuite/target/testdriver.log | grep -m 1 'is up and running' | grep -m 1 'is up and running' | sed -E 's/.*([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}).*/\1/'`

            # add cluster metadata to job which can delete the cluster later
            mkdir -p /var/jenkins_home/workspace/delete-cluster-common-self-service/clusters
            echo "'${CLUSTER_NICKNAME}' / created $(date  +'%Y-%m-%d %H:%M') by ${BUILD_USER}" > "/var/jenkins_home/workspace/delete-cluster-common-self-service/clusters/${CLUSTER_ID}"
    publishers:
      - archive:
          artifacts: 'testsuite/target/access.yaml'
          allow-empty: true
      - description-setter:
          regexp: ".*build_run_label::#(.*)#.*"
          regexp-for-failed: ".*build_run_label::#(.*)#"
          set-for-matrix: false
{% endfor %}

